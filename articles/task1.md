Task 1 - SignalR based chat
===

Goal was to make a simple chat using SignalR Core and ASP.NET Core web site

## Model

Only requirements for system were to show all active users, broadcast messages send by users for all to see and support message persistence. Due to this, the domain model for the system is fairly simple and small. Users have Id and Handle (nickname) and messages consist of Id, Handle (handle of the user who sent the message), timestamp (generated at server side) and the actual message text.

## General architecture

Backend system consist mostly of two layers, application layer and data access layer. Business layer/services were left out, for all commands originating from application layer would simply be pass through calls for services.

Application layer is very simple and consists of SignalR hub for basic chat functionality and api controllers for message history and active user fetching. SignalR has no backplane installed hence multiple servers are a no go. This would be a clear next step to make the system scale better.

Data access layer is described more in detail in storage section.

## Storage

Using Azure storage for chat message persistence was required by the task. Table storage was chosen over blob storage due to it having crude indexing capabilities which are enough for the chat system. "Inversed" timestamp (long.maxvalue - timestamp.ticks) row key for chat messages is used to guarantee messages are fetched in order automatically. Additionaly user and message models are simple enough to be stored as TableEntity without any custom functionality. 

Table storage access is hidden behind repository interfaces used in application layer. Both active users and messages have a simple repository interface for functionality required by the system. If channels, authentication and authorization were needed, these would probably be hidden behind a service layer which in turn would be used by application layer. A simple generic table client was implemented for basic CRUD operations against a single table. Both user and message repositories use that client. This allowed repositories to be a bit more testable and the more "complex" table storage related code was reused.

For storage configuration Options-pattern is used and configuration values are injected to clients as strongly typed objects.

## Front End

Front end is based loosely on ASP.NET Core React template with Webpack for building, bundling and minification. Front end is entirely coded in TypeScript and React. I'm by no means a react professional, so some patterns (like chat service) propably go against the React ideology.

For UI styling, Bootstrap 4 was chosen. Only because I've been using it recently. Definetly not the best/prettiest toolkit to use, but saved me some time.

In general, having had a bit more time, front-end would/should have seen more love.

## Documentation

For documentation, DocFX is used. Haven't been responsible for choosing documentation layer for a while, but after some googling and testing, DocFX seems to be a solid tool for .net documentation. Articles are in markdown and API/Code documentation is based on C# xml "triple slash" comments. Web site generated by the tool is hosted as part of the chat application for simplicity. All in all, pretty happy with the tool and will probably use it in personal project from now on.

## Deployment

A simple PowerShell script `deploy.ps1` based on Microsoft samples was made to setup continuous github deployment and free tier web app initialization.